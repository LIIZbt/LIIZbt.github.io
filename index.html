<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UTM Coordinate & GPS Precision</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .card-value {
            transition: all 0.3s ease-in-out;
        }
        .gemini-response p {
            margin-bottom: 1rem;
        }
         .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4f46e5; /* Indigo to match theme */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        /* Make all buttons use the requested color and white text */
        button {
            background-color: #27333d !important;
            color: #ffffff !important;
            border: none !important;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center min-h-screen py-8">

    <div class="w-full max-w-md mx-auto bg-white rounded-xl shadow-lg p-8 space-y-6">
        <!-- Header Section -->
        <div class="text-center">
            <h1 class="text-2xl font-bold text-slate-900">UTM Getterer</h1>
            <p class="text-slate-600 mt-1">Get UTM coordinates</p>
        </div>

        <!-- Action Button -->
        <button id="getLocationBtn" class="w-full bg-slate-700 hover:bg-slate-800 text-white font-bold py-3 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50">
            Click to get Coords
        </button>

        <!-- Status Display -->
        <div id="status" class="text-center text-sm font-medium text-slate-600 h-5"></div>

        <!-- Results Display -->
        <div id="results" class="space-y-4 hidden">
            <!-- GPS Precision Card -->
            <div class="bg-slate-50 border border-slate-200 rounded-lg p-4">
                <h3 class="font-semibold text-slate-800">GPS Precision</h3>
                <p class="text-3xl font-bold text-slate-700 mt-1 card-value"><span id="accuracy">--</span> meters</p>
            </div>

            <!-- UTM Coordinates Card -->
            <div class="bg-slate-50 border border-slate-200 rounded-lg p-4">
                <h3 class="font-semibold text-slate-800">UTM Coordinates (WGS84)</h3>
                <div class="grid grid-cols-2 gap-4 mt-2 text-center">
                    <div>
                        <p class="text-xs text-slate-500">Zone</p>
                        <p class="font-mono text-lg font-semibold text-slate-900 card-value" id="utm-zone">--</p>
                    </div>
                    <div>
                        <p class="text-xs text-slate-500">Hemisphere</p>
                        <p class="font-mono text-lg font-semibold text-slate-900 card-value" id="utm-hemisphere">--</p>
                    </div>
                    <div class="col-span-2">
                        <p class="text-xs text-slate-500">Easting (X)</p>
                        <p class="font-mono text-lg font-semibold text-slate-900 card-value" id="utm-easting">--</p>
                    </div>
                    <div class="col-span-2">
                        <p class="text-xs text-slate-500">Northing (Y)</p>
                        <p class="font-mono text-lg font-semibold text-slate-900 card-value" id="utm-northing">--</p>
                    </div>
                </div>
            </div>

             <!-- Action Buttons Section -->
            <div class="space-y-2">
                <button id="saveLocationBtn" class="w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 hidden">
                    Save Location
                </button>
                <button id="downloadListBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 hidden">
                    Download List (.txt)
                </button>
                <button id="clearListBtn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-400 focus:ring-opacity-50 hidden">
                    Clear All Saved
                </button>
            </div>

            <div id="geminiResultCard" class="bg-indigo-50 border border-indigo-200 rounded-lg p-4 hidden">
                <h3 class="font-semibold text-indigo-800">Location Analysis</h3>
                <div id="geminiLoader" class="loader hidden"></div>
                <div id="geminiResponse" class="text-slate-700 mt-2 text-sm gemini-response"></div>
            </div>

            <!-- Saved Locations Section -->
            <div id="savedLocationsContainer" class="hidden">
                <h3 class="text-lg font-semibold text-slate-900 mt-6 border-b pb-2">Saved Locations</h3>
                <div id="savedLocationsList" class="mt-4 space-y-3 max-h-60 overflow-y-auto pr-2">
                    <!-- Saved items will be injected here -->
                </div>
                <div class="mt-4">
                    <button id="plotBtn" class="w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-3 rounded-lg hidden">Plot Saved Locations</button>
                    <div class="mt-3">
                        <canvas id="plotCanvas" width="600" height="400" class="w-full border border-slate-200 rounded" style="background:#fff"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const getLocationBtn = document.getElementById('getLocationBtn');
        const statusEl = document.getElementById('status');
        const resultsEl = document.getElementById('results');
    const geminiResultCard = document.getElementById('geminiResultCard');
        const geminiLoader = document.getElementById('geminiLoader');
        const geminiResponseEl = document.getElementById('geminiResponse');
        const saveLocationBtn = document.getElementById('saveLocationBtn');
    const downloadListBtn = document.getElementById('downloadListBtn');
    const clearListBtn = document.getElementById('clearListBtn');
    const plotBtn = document.getElementById('plotBtn');
    const plotCanvas = document.getElementById('plotCanvas');
        const savedLocationsContainer = document.getElementById('savedLocationsContainer');
        const savedLocationsList = document.getElementById('savedLocationsList');

        // Result display elements
        const accuracyEl = document.getElementById('accuracy');
        const utmZoneEl = document.getElementById('utm-zone');
        const utmHemisphereEl = document.getElementById('utm-hemisphere');
        const utmEastingEl = document.getElementById('utm-easting');
        const utmNorthingEl = document.getElementById('utm-northing');

        let currentLat, currentLon, currentAccuracy;
        let savedLocations = [];

        getLocationBtn.addEventListener('click', () => {
            if (!navigator.geolocation) {
                statusEl.textContent = 'Geolocation is not supported by your browser.';
                return;
            }
            statusEl.textContent = 'Locating...';
            resultsEl.classList.add('hidden');
            saveLocationBtn.classList.add('hidden');
            geminiResultCard.classList.add('hidden');
            geminiResponseEl.innerHTML = '';

            navigator.geolocation.getCurrentPosition(handleSuccess, handleError, {
                enableHighAccuracy: true
            });
        });

    // geminiBtn.addEventListener('click', getNearbyInfo); // Removed geminiBtn event listener
        saveLocationBtn.addEventListener('click', saveCurrentLocation);
    downloadListBtn.addEventListener('click', downloadSavedLocations);
    clearListBtn.addEventListener('click', clearSavedLocations);
    plotBtn.addEventListener('click', renderPlot);

        function handleSuccess(position) {
            statusEl.textContent = 'Location Found!';
            resultsEl.classList.remove('hidden');
            // (Get Location Analysis button removed)
            saveLocationBtn.classList.remove('hidden');

            currentLat = position.coords.latitude;
            currentLon = position.coords.longitude;
            currentAccuracy = position.coords.accuracy;

            const utm = convertLatLonToUTM(currentLat, currentLon);

            // Update UI with faded-in values
            updateValue(accuracyEl, Math.round(currentAccuracy));
            
            updateValue(utmZoneEl, `${utm.zoneNum}${utm.zoneLetter}`);
            updateValue(utmHemisphereEl, utm.hemisphere);
            updateValue(utmEastingEl, utm.easting.toFixed(0));
            updateValue(utmNorthingEl, utm.northing.toFixed(0));
        }

        function handleError(error) {
            let errorMessage = 'An unknown error occurred.';
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage = "User denied the request for Geolocation.";
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage = "Location information is unavailable.";
                    break;
                case error.TIMEOUT:
                    errorMessage = "The request to get user location timed out.";
                    break;
                case error.UNKNOWN_ERROR:
                    errorMessage = "An unknown error occurred.";
                    break;
            }
            statusEl.textContent = errorMessage;
        }

        function updateValue(element, value) {
            element.classList.add('opacity-0');
            setTimeout(() => {
                element.textContent = value;
                element.classList.remove('opacity-0');
            }, 100);
        }

        // --- Save Location Feature ---
        function saveCurrentLocation() {
            if (currentLat === undefined || currentLon === undefined) return;

            const timestamp = new Date();
            const locationData = {
                id: timestamp.getTime(),
                timestamp: timestamp.toLocaleString(),
                accuracy: Math.round(currentAccuracy),
                utmZone: utmZoneEl.textContent,
                utmEasting: utmEastingEl.textContent,
                utmNorthing: utmNorthingEl.textContent,
            };

            savedLocations.unshift(locationData); // Add to the beginning
            renderSavedLocations();
        }

        function renderSavedLocations() {
            if (savedLocations.length === 0) {
                savedLocationsContainer.classList.add('hidden');
                downloadListBtn.classList.add('hidden');
                clearListBtn.classList.add('hidden');
                return;
            }

            savedLocationsContainer.classList.remove('hidden');
            downloadListBtn.classList.remove('hidden');
            clearListBtn.classList.remove('hidden');
            plotBtn.classList.remove('hidden');
            savedLocationsList.innerHTML = ''; // Clear existing list

            savedLocations.forEach(location => {
                const itemEl = document.createElement('div');
                itemEl.className = 'bg-slate-50 border border-slate-200 rounded-lg p-3 text-sm animate-fade-in';
                itemEl.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span class="font-semibold text-slate-800">Saved: ${location.timestamp}</span>
                            <div class="flex items-center space-x-2">
                                <button data-id="${location.id}" class="copy-btn bg-slate-200 hover:bg-slate-300 text-slate-800 px-2 py-1 rounded text-xs">Copy</button>
                            </div>
                    </div>
                    <div class="mt-2 space-y-1 text-slate-600 font-mono">
                        <div>Acc: <span class="font-semibold text-slate-800 float-right">${location.accuracy}m</span></div>
                        <div>Zone: <span class="font-semibold text-slate-800 float-right">${location.utmZone}</span></div>
                        <div>Easting: <span class="font-semibold text-slate-800 float-right">${location.utmEasting}</span></div>
                        <div>Northing: <span class="font-semibold text-slate-800 float-right">${location.utmNorthing}</span></div>
                    </div>
                `;
                savedLocationsList.appendChild(itemEl);
            });

                // Attach copy handlers
                document.querySelectorAll('.copy-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = Number(e.currentTarget.getAttribute('data-id'));
                        const loc = savedLocations.find(s => s.id === id);
                        if (!loc) return;
                        const text = formatLocationText(loc);
                        navigator.clipboard?.writeText(text).then(() => {
                            // brief visual feedback
                            const orig = e.currentTarget.textContent;
                            e.currentTarget.textContent = 'Copied';
                            setTimeout(() => e.currentTarget.textContent = orig, 1200);
                        }).catch(() => {
                            // fallback
                            alert(text);
                        });
                    });
                });
            // If there are saved locations, draw/update the plot automatically
            if (savedLocations.length > 0) {
                try { renderPlot(); } catch (e) { console.warn('Plot failed', e); }
            }
        }

            // Format a single location as plain text
            function formatLocationText(loc) {
                return `Saved: ${loc.timestamp}\nAccuracy: ${loc.accuracy} m\nZone: ${loc.utmZone}\nEasting: ${loc.utmEasting}\nNorthing: ${loc.utmNorthing}`;
            }

            // Build and download the saved locations as a .txt file
            function downloadSavedLocations() {
                if (savedLocations.length === 0) {
                    alert('No saved locations to download.');
                    return;
                }

                const lines = savedLocations.map((loc, idx) => `#${idx + 1}\n${formatLocationText(loc)}`).join('\n\n');
                const blob = new Blob([lines], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `saved-locations-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.txt`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            }

            function clearSavedLocations() {
                if (!confirm('Clear all saved locations?')) return;
                savedLocations = [];
                renderSavedLocations();
                clearCanvas();
            }

            function clearCanvas() {
                const ctx = plotCanvas.getContext('2d');
                ctx.clearRect(0,0,plotCanvas.width, plotCanvas.height);
            }

            // Render a 2D plot of savedLocations zeroed to the first point
            function renderPlot() {
                if (savedLocations.length === 0) {
                    alert('No saved locations to plot.');
                    return;
                }

                const ctx = plotCanvas.getContext('2d');
                const W = plotCanvas.width;
                const H = plotCanvas.height;
                ctx.clearRect(0,0,W,H);

                // Parse numbers from saved locations (easting/northing expected to be strings)
                const pts = savedLocations.map(s => ({
                    x: Number(String(s.utmEasting).replace(/[^0-9.-]/g,'')),
                    y: Number(String(s.utmNorthing).replace(/[^0-9.-]/g,'')),
                    label: s.timestamp
                }));

                // Zero to first point
                const origin = pts[0];
                const rel = pts.map(p => ({ x: p.x - origin.x, y: p.y - origin.y, label: p.label }));

                // Determine bounds
                const xs = rel.map(p => p.x);
                const ys = rel.map(p => p.y);
                const minX = Math.min(...xs);
                const maxX = Math.max(...xs);
                const minY = Math.min(...ys);
                const maxY = Math.max(...ys);

                // Add margins
                const margin = 40;
                const plotW = W - margin*2;
                const plotH = H - margin*2;

                // Handle degenerate cases
                const rangeX = (maxX - minX) || 1;
                const rangeY = (maxY - minY) || 1;

                // Scale to fit, preserving aspect (meters)
                const scale = Math.min(plotW / rangeX, plotH / rangeY) * 0.9; // padding

                // Translate function: UTM coords -> canvas coords
                const toCanvas = (p) => {
                    const cx = margin + ((p.x - minX) * scale) + (plotW - rangeX*scale)/2;
                    // invert Y for canvas (northing up)
                    const cy = margin + plotH - ((p.y - minY) * scale) - (plotH - rangeY*scale)/2;
                    return { cx, cy };
                };

                // Draw axes (origin at first point)
                ctx.strokeStyle = '#cbd5e1';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // X axis (relative to origin)
                const originCanvas = toCanvas({ x: 0 - minX, y: 0 - minY });
                ctx.moveTo(margin, originCanvas.cy);
                ctx.lineTo(W - margin, originCanvas.cy);
                // Y axis
                ctx.moveTo(originCanvas.cx, margin);
                ctx.lineTo(originCanvas.cx, H - margin);
                ctx.stroke();

                // Draw grid lines (optional: every nice interval in meters)
                ctx.fillStyle = '#334155';
                ctx.font = '12px monospace';

                // Draw polyline connecting points
                ctx.strokeStyle = '#111827';
                ctx.lineWidth = 2;
                ctx.beginPath();
                rel.forEach((p, i) => {
                    const { cx, cy } = toCanvas(p);
                    if (i === 0) ctx.moveTo(cx, cy); else ctx.lineTo(cx, cy);
                });
                ctx.stroke();

                // Draw points and labels
                rel.forEach((p, i) => {
                    const { cx, cy } = toCanvas(p);
                    ctx.beginPath();
                    ctx.fillStyle = (i === 0) ? '#ef4444' : '#0ea5a4'; // red for origin, teal for others
                    ctx.arc(cx, cy, 5, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#0f172a';
                    ctx.fillText(`#${i+1}`, cx + 8, cy - 6);
                });

                // Legend / origin info
                ctx.fillStyle = '#0f172a';
                ctx.fillText(`Origin (zeroed): ${origin.x.toFixed(0)}, ${origin.y.toFixed(0)}`, margin, 14);
            }

        // --- Gemini API Integration ---
        // Get Location Analysis (Gemini) feature removed per request. Keeping result card in case it's reused later.


        /**
         * Converts Latitude and Longitude to UTM coordinates.
         * Based on the WGS84 ellipsoid.
         * @param {number} lat - Latitude in decimal degrees.
         * @param {number} lon - Longitude in decimal degrees.
         * @returns {object} An object containing UTM easting, northing, zone number, zone letter, and hemisphere.
         */
        function convertLatLonToUTM(lat, lon) {
            // WGS84 Ellipsoid constants
            const a = 6378137; // semi-major axis
            const eccSquared = 0.00669438;
            const k0 = 0.9996;

            const lonOrigin = (Math.floor((lon + 180) / 6) * 6) - 177;
            const lonOriginRad = lonOrigin * Math.PI / 180;

            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;

            const eccPrimeSquared = eccSquared / (1 - eccSquared);

            const N = a / Math.sqrt(1 - eccSquared * Math.sin(latRad) * Math.sin(latRad));
            const T = Math.tan(latRad) * Math.tan(latRad);
            const C = eccPrimeSquared * Math.cos(latRad) * Math.cos(latRad);
            const A = Math.cos(latRad) * (lonRad - lonOriginRad);

            const M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * latRad -
                (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * latRad) +
                (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * latRad) -
                (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * latRad));

            const UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6 +
                (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120) +
                500000.0);

            let UTMNorthing = (k0 * (M + N * Math.tan(latRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24 +
                (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720)));

            if (lat < 0) {
                UTMNorthing += 10000000.0; // 10000000 meter offset for southern hemisphere
            }
            
            const zoneNum = Math.floor((lon + 180) / 6) + 1;
            
            return {
                easting: UTMEasting,
                northing: UTMNorthing,
                zoneNum: zoneNum,
                zoneLetter: getUTMZoneLetter(lat),
                hemisphere: lat >= 0 ? 'North' : 'South'
            };
        }
        
        /**
         * Determines the UTM zone letter based on latitude.
         * @param {number} lat - Latitude in decimal degrees.
         * @returns {string} The UTM zone letter.
         */
        function getUTMZoneLetter(lat) {
            const letters = 'CDEFGHJKLMNPQRSTUVWXX';
            if (-80 <= lat && lat <= 84) {
                return letters.charAt(Math.floor(lat + 80) / 8);
            } else {
                return 'Z'; // Special case for poles
            }
        }
    </script>

</body>
</html>
